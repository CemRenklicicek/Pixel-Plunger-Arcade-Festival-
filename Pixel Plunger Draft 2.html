<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Pixel Plunger</title>
<style>
  body { margin: 0; overflow: hidden; background: #8da8ba; font-family: Arial, sans-serif; }
  canvas { display: block; background: #8da8ba; }

  /* Win overlay */
  #winOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 20;
    padding: 20px;
    text-align: center;
  }

  #winOverlay.show {
    opacity: 1;
    pointer-events: auto;
  }

  #winMessage {
    font-size: 48px;
    color: gold;
    text-align: center;
    text-shadow: 2px 2px 10px #000;
    margin-bottom: 20px;
    max-width: 90%;
    line-height: 1.3;
  }

  #funFact {
    font-size: 28px;
    color: white;
    margin-bottom: 30px;
    max-width: 90%;
  }

  #restartButton {
    padding: 15px 40px;
    font-size: 28px;
    background: gold;
    color: black;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  #restartButton:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px gold;
  }

  /* Start screen */
  #startScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: #1c1c1c;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    margin: 0;
    padding: 0;
    height: 100vh;
    text-align: center;
    z-index: 100;
  }

  #startScreen h1 {
    font-size: 130px;
    margin-bottom: 20px;
    color: gold;
    text-shadow: 2px 2px 5px #000;
  }

  #startScreen p {
    font-size: 35px;
    max-width: 1000px;
    margin-bottom: 50px;
  }

  #controlsInfo {
    font-size: 35px;
    margin-bottom: 35px;
    max-width: 1500px;
  }

  #startButton {
    padding: 20px 40px;
    font-size: 28px;
    cursor: pointer;
    background: gold;
    color: black;
    border: none;
    margin-bottom: 80px;
    border-radius: 10px;
    transition: transform 0.2s;
  }

  #startButton:hover {
    transform: scale(1.05);
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="startScreen">
  <h1>Pixel Plunger</h1>
  <p>Spring door de grote oppervlakte boven jou om schatten te pakken. Verzamel genoeg schatten om te winnen. Bonuspunten verdien je door snel te zijn</p>
  <div id="controlsInfo">
    Toets "A" om naar links te gaan<br>
    Toets "D" om naar rechts te gaan<br>
    Toets "Spatie" om te springen<br>
    Toets "Spatie" meerdere keren om hoger te komen
  </div>
  <button id="startButton">Beginnen</button>
</div>

<div id="winOverlay">
  <div id="winMessage"></div>
  <div id="funFact"></div>
  <button id="restartButton">Speel nogmaals</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = { x: 200, y: canvas.height - 100, size: 60, vx: 0, vy: 0 };
let keys = {};
let gravity = 0.6; // slower fall for elderly
let ceilingHeight = canvas.height * 2/3;
let groundY = canvas.height - 80;
let ceilingHoles = [];
let groundHoles = [];
let treasures = [];
let collectedTreasures = 0;
let requiredTreasures = Math.floor(Math.random() * 8) + 12; // slightly less
let totalTreasures = 40;
let scrollX = 0;
let invisibleWallLeft = null;
let invisibleWallRight = null;
let playerScreenX = canvas.width / 2 - player.size / 2;

const winOverlay = document.getElementById('winOverlay');
const winMessage = document.getElementById('winMessage');
const funFactDiv = document.getElementById('funFact');
const restartButton = document.getElementById('restartButton');
const startScreen = document.getElementById('startScreen');
const startButton = document.getElementById('startButton');

let showHUD = true;
let startTime = Date.now();
let winTime = null;
let finalPoints = 0;

const treasureColors = ['gold', 'red', 'blue', 'green', 'purple', 'orange', 'pink', 'cyan'];
const treasureShapes = ['square','circle','triangle'];

// Fun facts about games / arcade for elderly
const funFacts = [
"Wist je dat het eerste arcadespel 'Computer Space' in 1971 uitkwam?",
"Wist je dat Pong een van de eerste populaire arcadespellen was in 1972?",
"Wist je dat Pac-Man oorspronkelijk 'Puck Man' heette?",
"Wist je dat Space Invaders in 1978 een enorme arcade rage veroorzaakte?",
"Wist je dat Donkey Kong de eerste game was waarin Mario verscheen?",
"Wist je dat de allereerste computerspelletjes al in de jaren 50 werden gemaakt, zoals “Tennis for Two”?",
"Wist je dat Tetris in 1984 uitkwam en nog steeds geliefd is?",
"Wist je dat de eerste joystick werd gebruikt in de jaren 60 voor computerspellen?",
"Wist je dat Frogger in 1981 werd uitgebracht en beroemd werd om zijn verkeersuitdaging?",
"Wist je dat Mario Bros. oorspronkelijk Luigi als tweede speler introduceerde?",
"Wist je dat Galaga een vervolg was op het oudere Galaxian-spel?",
"Wist je dat de meeste oude arcade spellen ontworpen waren om zo snel mogelijk geld te verdienen?",
"Wist je dat Street Fighter II in 1991 een revolutie in vechtgames veroorzaakte?",
"Wist je dat Pac-Man's ontwerp werd geïnspireerd door een pizzapunt?",
"Wist je dat de videospelcrash van 1983 in de VS werd veroorzaakt door overproductie en slechte kwaliteit spellen?"
];

// Generate treasures with bigger size and closer distances
function generateTreasures(startX, count) {
    treasures = [];
    let positions = [];
    let spacing = Math.floor(canvas.width / 2); // closer spacing
    for(let i=0; i<count; i++){
        let size = 50 + Math.random()*30; // bigger treasures
        let x;
        do { x = startX + i*spacing + Math.random()*100; }
        while(positions.some(p => Math.abs(p - x) < size + 20));
        positions.push(x);
        let y = Math.random()*(ceilingHeight/2);
        let color = treasureColors[Math.floor(Math.random()*treasureColors.length)];
        let shape = treasureShapes[Math.floor(Math.random()*treasureShapes.length)];
        treasures.push({ x, y, size, color, shape, collected: false });
    }
    if(positions.length > 0){
        invisibleWallLeft = positions[0] - 50;
        invisibleWallRight = positions[positions.length-1] + 50;
    }
}

generateTreasures(player.x - 2000, totalTreasures);

function drawHills(offset) {
    ctx.fillStyle = '#2e6a3d';
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    for (let x = 0; x <= canvas.width; x++) {
        let y = groundY - 15 * Math.sin((x + offset) * 0.003);
        ctx.lineTo(x, y);
    }
    ctx.lineTo(canvas.width, canvas.height);
    ctx.lineTo(0, canvas.height);
    ctx.closePath();
    ctx.fill();
}

function drawCeiling() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, ceilingHeight);
    ctx.fillStyle = '#8da7ba';
    ceilingHoles.forEach(h => ctx.fillRect(h.x - scrollX, h.y, h.size, h.size));
    treasures.forEach(t => {
        if(!t.collected) {
            ctx.fillStyle = t.color;
            ctx.shadowColor = t.color;
            ctx.shadowBlur = 15;
            switch(t.shape){
                case 'square': ctx.fillRect(t.x - scrollX, t.y, t.size, t.size); break;
                case 'circle': ctx.beginPath(); ctx.arc(t.x - scrollX + t.size/2, t.y + t.size/2, t.size/2, 0, Math.PI*2); ctx.fill(); break;
                case 'triangle': ctx.beginPath(); ctx.moveTo(t.x - scrollX + t.size/2, t.y); ctx.lineTo(t.x - scrollX, t.y + t.size); ctx.lineTo(t.x - scrollX + t.size, t.y + t.size); ctx.closePath(); ctx.fill(); break;
            }
            ctx.shadowBlur = 0;
        }
    });
}

function drawPlayer() {
    ctx.fillStyle = '#FF4500';
    ctx.shadowColor = 'rgba(255, 69, 0, 0.8)';
    ctx.shadowBlur = 25;
    ctx.fillRect(playerScreenX, player.y, player.size, player.size);
    ctx.shadowBlur = 0;
}

let particles = [];
function updatePlayer() {
    let speed = 8; // slower for elderly
    player.vx = 0;
    if(keys['a']) player.vx = -speed;
    if(keys['d']) player.vx = speed;

    player.x += player.vx;
    player.vy += gravity;
    player.y += player.vy;

    let visibleTreasures = treasures.filter(t => !t.collected);
    if(visibleTreasures.length > 0){
        invisibleWallLeft = Math.min(...visibleTreasures.map(t => t.x)) - 50;
        invisibleWallRight = Math.max(...visibleTreasures.map(t => t.x)) + 50;
    }
    if(player.x < invisibleWallLeft) player.x = invisibleWallLeft;
    if(player.x + player.size > invisibleWallRight) player.x = invisibleWallRight - player.size;

    let groundLevel = groundY - 15 * Math.sin(player.x * 0.003);
    if(player.y + player.size > groundLevel) { player.y = groundLevel - player.size; player.vy = 0; }
    if(player.y < 0) { player.y = 0; player.vy = 0; }

    if(player.y < ceilingHeight && player.y > 0) {
        let hole = { x: player.x - 10, y: player.y, size: player.size + 20 };
        ceilingHoles.push(hole);
        for(let i=0; i<15; i++){
            let hue = Math.floor(Math.random()*360);
            particles.push({ x: hole.x + hole.size/2, y: hole.y + hole.size/2, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, alpha:1, color:`hsl(${hue},100%,50%)` });
        }
    }

    treasures.forEach(t => {
        if(!t.collected){
            let px = player.x + player.size/2;
            let py = player.y + player.size/2;
            let tx = t.x + t.size/2;
            let ty = t.y + t.size/2;
            let dist = Math.sqrt((px-tx)**2 + (py-ty)**2);
            if(dist < player.size/2){
                t.collected = true;
                collectedTreasures++;
                for(let i=0; i<10; i++){
                    particles.push({ x: t.x+t.size/2, y: t.y+t.size/2, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, alpha:1, color: t.color });
                }
            }
        }
    });

    // Win condition
    if(collectedTreasures >= requiredTreasures && winTime === null){
        winTime = Date.now();
        let elapsed = (winTime - startTime)/1000;
        let bonus = Math.max(0, Math.floor(50 + Math.max(0, (60 - elapsed)))); // 50 points after ~1 minute
        finalPoints = collectedTreasures + bonus;
        winMessage.innerHTML = `Je hebt alle benodigde schatten verzameld.<br>Goed gedaan!<br>Score: ${finalPoints} (Bonus: ${bonus})`;

        // Random fun fact
        funFactDiv.innerHTML = funFacts[Math.floor(Math.random()*funFacts.length)];

        winOverlay.classList.add('show');
        showHUD = false;
    }

    scrollX = player.x - playerScreenX;
}

function updateParticles(){
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.alpha -= 0.02; });
    particles = particles.filter(p=>p.alpha>0);
}
function drawParticles(){
    particles.forEach(p => { 
        ctx.fillStyle = p.color.startsWith('hsl') ? p.color.replace(/,1\)/,`,`+p.alpha+`)`) : `rgba(${p.color==='red'?255:p.color==='blue'?0:p.color==='green'?0:p.color==='purple'?128:p.color==='orange'?255:p.color==='pink'?255:0},${p.color==='red'?0:p.color==='blue'?0:p.color==='green'?255:p.color==='purple'?0:p.color==='orange'?165:p.color==='pink'?192:255},${p.color==='red'?0:p.color==='blue'?255:p.color==='green'?0:p.color==='purple'?128:p.color==='orange'?0:p.color==='pink'?203:0},${p.alpha})`; 
        ctx.fillRect(p.x - scrollX, p.y, 5, 5); 
    });
}

function drawHoles() { ctx.fillStyle = '#2e4e65'; groundHoles.forEach(h => ctx.fillRect(h.x - scrollX, h.y, h.size, h.size)); }

function drawHUD() {
    if(showHUD){
        ctx.fillStyle = 'white';
        ctx.font = '36px Arial';
        ctx.fillText(`Schatten: ${collectedTreasures} / ${requiredTreasures}`, 20, 50);
        let elapsed = Math.floor((Date.now()-startTime)/1000);
        ctx.fillText(`Tijd: ${elapsed}s`, 20, 100);
    }
}

function gameLoop() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawCeiling(); drawHills(scrollX); drawHoles(); drawParticles(); drawPlayer(); drawHUD();
    updatePlayer(); updateParticles();
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' ') player.vy=-25; });
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

restartButton.addEventListener('click', () => {
    player.x = 200; player.y = canvas.height-100; player.vx=0; player.vy=0;
    scrollX=0; collectedTreasures=0; ceilingHoles=[]; groundHoles=[]; particles=[];
    requiredTreasures = Math.floor(Math.random()*8)+12;
    startTime = Date.now();
    winTime = null;
    finalPoints = 0;
    generateTreasures(player.x - 2000, totalTreasures);
    showHUD = true; winOverlay.classList.remove('show');
});

startButton.addEventListener('click', () => {
    startScreen.style.display = 'none';
    startTime = Date.now();
    gameLoop();
});

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  ceilingHeight = canvas.height * 2/3;
  groundY = canvas.height - 80;
  playerScreenX = canvas.width / 2 - player.size / 2;
});
</script>
</body>
</html>
